package com.gooddata.jdbc.driver;

import com.gooddata.jdbc.util.LoggingInvocationHandler;
import com.gooddata.sdk.model.executeafm.Execution;
import com.gooddata.sdk.model.executeafm.ObjQualifier;
import com.gooddata.sdk.model.executeafm.UriObjQualifier;
import com.gooddata.sdk.model.executeafm.afm.*;
import com.gooddata.sdk.model.executeafm.response.ExecutionResponse;
import com.gooddata.sdk.model.executeafm.result.ExecutionResult;
import com.gooddata.sdk.model.md.Attribute;
import com.gooddata.sdk.model.md.DisplayForm;
import com.gooddata.sdk.model.md.Entry;
import com.gooddata.sdk.model.md.Metric;
import com.gooddata.sdk.model.project.Project;
import com.gooddata.sdk.service.FutureResult;
import com.gooddata.sdk.service.GoodData;
import com.gooddata.sdk.service.executeafm.ExecuteAfmService;
import com.gooddata.sdk.service.md.MetadataService;
import net.sf.jsqlparser.JSQLParserException;

import java.lang.reflect.Proxy;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.ResultSet;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public class Statement implements java.sql.Statement {

	private final static Logger LOGGER = Logger.getLogger(Statement.class.getName());



	private final GoodData gd;
	private final Project workspace;
	private final Connection connection;
	private final DatabaseMetaData metadata;
	private final ExecuteAfmService gdAfm;

    private boolean isClosed = false;
	private ResultSet resultSet;
    private int maxRows = 0;


	/**
	 * Constructor\
	 * @param con java.sql.Connection
	 * @param gd GoodData connection class
	 * @param metadata database metadata
	 */
	public Statement(Connection con, GoodData gd, DatabaseMetaData metadata) {
		this.connection = con;
		this.gd = gd;
		this.metadata = metadata;
		this.workspace = metadata.getWorkspace();
		this.gdAfm = gd.getExecuteAfmService();
	}

	/**
	 * Populates AFM execution parameter
	 * @param columns resolved SQL columns
	 * @return AFM object
	 * @throws DatabaseMetaData.DuplicateLdmObjectException when there are multiple LDM object with a named mentioned in the parsed SQL
	 * @throws DatabaseMetaData.LdmObjectNotFoundException when a SQL object (column) can't be resolved
	 */
	private Afm getAfm(List<DatabaseMetaData.CatalogEntry> columns) throws DatabaseMetaData.DuplicateLdmObjectException,
			DatabaseMetaData.LdmObjectNotFoundException {
		Afm afm = new Afm();
		for( DatabaseMetaData.CatalogEntry o: columns ) {
			if(o.getType().equalsIgnoreCase("attributeDisplayForm")) {
				afm.addAttribute(new AttributeItem(o.getLdmObject(), o.getIdentifier()));
			} else if(o.getType().equalsIgnoreCase("metric")) {
				afm.addMeasure(new MeasureItem( new SimpleMeasureDefinition(o.getLdmObject()),
						o.getIdentifier()));
			}
		}
		return afm;
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query (only SELECTs are supported)
	 * @return ResultSet
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		try {
			SQLParser parser = new SQLParser();
			SQLParser.ParsedSQL parsedSql = parser.parse(sql);
			List<DatabaseMetaData.CatalogEntry> columns = this.metadata.resolveColumns(parsedSql);
			Afm afm = getAfm(columns);
			ExecutionResponse rs = this.gdAfm.executeAfm(this.workspace, new Execution(afm));
			FutureResult<ExecutionResult> fr = this.gdAfm.getResult(rs);
			return (java.sql.ResultSet) Proxy.newProxyInstance(
					Driver.class.getClassLoader(),
					new Class[] { java.sql.ResultSet.class },
					new LoggingInvocationHandler(new ResultSetTable(this, fr.get(), columns)));
		} catch (JSQLParserException | DatabaseMetaData.LdmObjectNotFoundException
				| DatabaseMetaData.DuplicateLdmObjectException e) {
			throw new SQLException(e);
		}
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query (only SELECTs are supported)
	 * @return true in case of success
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql) throws SQLException {
		this.resultSet = this.executeQuery(sql);
		return true;
	}

	@Override
	public java.sql.ResultSet getResultSet()  {
		return this.resultSet;
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param autoGeneratedKeys ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return execute(sql);
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param columnIndexes ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return execute(sql);
	}
	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param columnNames ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return execute(sql);
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}


	@Override
	public int executeUpdate(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void close() {
        this.isClosed=true;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int getMaxRows() {
		return this.maxRows;
	}

	@Override
	public void setMaxRows(int max){
        this.maxRows=max;
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void cancel() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		//throw new SQLFeatureNotSupportedException("Not supported yet.");
		return new SQLWarning();
	}

	@Override
	public void clearWarnings() throws SQLException {
		//throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int getUpdateCount() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return ResultSetTable.FETCH_DIRECTION;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		//throw new SQLFeatureNotSupportedException("Not supported yet");
	}

	@Override
	public int getFetchSize() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet");
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return ResultSetTable.CONCURRENCY;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return ResultSetTable.TYPE;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void clearBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public Connection getConnection() {
		return this.connection;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		//throw new SQLFeatureNotSupportedException("Not supported yet.");
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return ResultSetTable.HOLDABILITY;
	}

	@Override
	public boolean isClosed() {
		return this.isClosed;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public boolean isPoolable() throws SQLException {
		throw new SQLFeatureNotSupportedException("Not supported yet.");
	}

	@Override
	public void closeOnCompletion() {
		this.isClosed = true;
	}

	@Override
	public boolean isCloseOnCompletion() {
		return this.isClosed;
	}

}
