package com.gooddata.jdbc.driver;

import com.gooddata.sdk.model.executeafm.Execution;
import com.gooddata.sdk.model.executeafm.afm.*;
import com.gooddata.sdk.model.executeafm.response.ExecutionResponse;
import com.gooddata.sdk.model.executeafm.result.ExecutionResult;
import com.gooddata.sdk.model.project.Project;
import com.gooddata.sdk.service.FutureResult;
import com.gooddata.sdk.service.GoodData;
import com.gooddata.sdk.service.executeafm.ExecuteAfmService;
import com.gooddata.sdk.service.md.MetadataService;
import net.sf.jsqlparser.JSQLParserException;

import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.ResultSet;
import java.util.*;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Statement implements java.sql.Statement {

	private final static Logger LOGGER = Logger.getLogger(Statement.class.getName());

	private final Project workspace;
	private final Connection connection;
	private final DatabaseMetaData metadata;
	private final ExecuteAfmService gdAfm;

    private boolean isClosed = false;
	private ResultSet resultSet;
    private int maxRows = 0;

    private int fetchSize = 0;


	/**
	 * Constructor\
	 * @param con java.sql.Connection
	 * @param gd GoodData connection class
	 * @param metadata database metadata
	 */
	public Statement(Connection con, GoodData gd, DatabaseMetaData metadata) {
		this.connection = con;
		this.metadata = metadata;
		this.workspace = metadata.getWorkspace();
		this.gdAfm = gd.getExecuteAfmService();
	}

	/**
	 * Populates AFM execution parameter
	 * @param columns AFM columns
	 * @param filters AFM filters
	 * @return AFM object
	 * @throws AfmColumn.DuplicateLdmObjectException when there are multiple LDM object with a named mentioned in the parsed SQL
	 * @throws AfmColumn.LdmObjectNotFoundException when a SQL object (column) can't be resolved
	 */
	private Afm getAfm(List<AfmColumn> columns, List<AfmFilter> filters) throws AfmColumn.DuplicateLdmObjectException,
			AfmColumn.LdmObjectNotFoundException, SQLException {
		Afm afm = new Afm();
		for( AfmColumn o: columns ) {
			if(o.getType().equalsIgnoreCase("attributeDisplayForm")) {
				afm.addAttribute(new AttributeItem(o.getLdmObject(), o.getIdentifier()));
			} else if(o.getType().equalsIgnoreCase("metric")) {
				afm.addMeasure(new MeasureItem( new SimpleMeasureDefinition(o.getLdmObject()),
						o.getIdentifier()));
			}
		}
		for( AfmFilter f: filters ) {
			afm.addFilter(f.getFilterObj());
		}
		return afm;
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query (only SELECTs are supported)
	 * @return ResultSet
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		try {
			SQLParser parser = new SQLParser();
			SQLParser.ParsedSQL parsedSql = parser.parse(sql);
			List<AfmColumn> columns = this.metadata.getCatalog().resolveAfmColumns(parsedSql);
			List<AfmFilter> filters = this.metadata.getCatalog().resolveAfmFilters(parsedSql);
			Afm afm = getAfm(columns, filters);
			ExecutionResponse rs = this.gdAfm.executeAfm(this.workspace, new Execution(afm));
			FutureResult<ExecutionResult> fr = this.gdAfm.getResult(rs);
			ResultSet r = new ResultSetTable(this, fr.get(), columns);
			return r;
		} catch (JSQLParserException | AfmColumn.LdmObjectNotFoundException
				| AfmColumn.DuplicateLdmObjectException e) {
			throw new SQLException(e);
		}
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query (only SELECTs are supported)
	 * @return true in case of success
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql) throws SQLException {
		if(sql.trim().toLowerCase().startsWith("create")) {
			try {
				SQLParser parser = new SQLParser();
				SQLParser.ParsedCreateMetricStatement parsedCreate = parser.parseCreateMetric(sql);
				this.metadata.getCatalog().executeCreateMetric(parsedCreate);
			} catch (AfmColumn.LdmObjectNotFoundException | AfmColumn.DuplicateLdmObjectException |
					JSQLParserException e) {
				throw new SQLException(e);
			}
		} else if(sql.trim().toLowerCase().startsWith("drop")) {
			try {
				SQLParser parser = new SQLParser();
				String parsedDropMetric = parser.parseDropMetric(sql);
				this.metadata.getCatalog().executeDropMetric(parsedDropMetric);
			} catch (AfmColumn.LdmObjectNotFoundException | AfmColumn.DuplicateLdmObjectException |
					JSQLParserException e) {
				throw new SQLException(e);
			}
		}
		else {
			this.resultSet = this.executeQuery(sql);
		}
		return true;
	}

	@Override
	public java.sql.ResultSet getResultSet()  {
		return this.resultSet;
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param autoGeneratedKeys ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return execute(sql);
	}

	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param columnIndexes ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return execute(sql);
	}
	/**
	 * Executes SQL query
	 * @param sql SQL query
	 * @param columnNames ignored
	 * @return true in case when everything is fine
	 * @throws SQLException in case of execution problems
	 */
	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return execute(sql);
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.unwrap is not supported yet.");
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.isWrapperFor is not supported yet.");
	}


	@Override
	public int executeUpdate(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.executeUpdate is not supported yet.");
	}

	@Override
	public void close() {
        this.isClosed=true;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getMaxFieldSize is not supported yet.");
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setMaxFieldSize is not supported yet.");
	}

	@Override
	public int getMaxRows() {
		return this.maxRows;
	}

	@Override
	public void setMaxRows(int max){
        this.maxRows=max;
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setEscapeProcessing is not supported yet.");
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getQueryTimeout is not supported yet.");
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setQueryTimeout is not supported yet.");
	}

	@Override
	public void cancel() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.cancel is not supported yet.");
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getWarnings is not supported yet.");
	}

	@Override
	public void clearWarnings() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.clearWarnings is not supported yet.");
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setCursorName is not supported yet.");
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return -1;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setFetchDirection is not supported yet.");
	}

	@Override
	public int getFetchDirection() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getFetchDirection is not supported yet.");
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		this.fetchSize = rows;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return this.fetchSize;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getResultSetConcurrency is not supported yet.");
	}

	@Override
	public int getResultSetType() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getResultSetType is not supported yet.");
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.addBatch is not supported yet.");
	}

	@Override
	public void clearBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.clearBatch is not supported yet.");
	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.executeBatch is not supported yet.");
	}

	@Override
	public Connection getConnection() {
		return this.connection;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getGeneratedKeys is not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.executeUpdate is not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.executeUpdate is not supported yet.");
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.executeUpdate is not supported yet.");
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.getResultSetHoldability is not supported yet.");
	}

	@Override
	public boolean isClosed() {
		return this.isClosed;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.setPoolable is not supported yet.");
	}

	@Override
	public boolean isPoolable() throws SQLException {
		throw new SQLFeatureNotSupportedException("Statement.isPoolable is not supported yet.");
	}

	@Override
	public void closeOnCompletion() {
		this.isClosed = true;
	}

	@Override
	public boolean isCloseOnCompletion() {
		return this.isClosed;
	}

}
